# ChainHash

# 1. HashTable

<br/>

<br/>

## 1-A. What is Hash?

<br/>

<br/>

![ChainHash_Figure1-1](https://i.imgur.com/O7dBcWU.png)

<br/>

The general data structures that I have introduced has some problems of wasting. For example, the **ArrayList** which is an LinkedList using array has problem of **causing unnecessary movements when trying to delete one node**. As you can see in _Figure 1-1_, the **deleting one node in ArrayList causes the problem of movements of other behind nodes** which causes wasting time.

<br/>

<br/>

![CahinHash_Figure1-2](https://i.imgur.com/GavPx77.png)

<br/>

For dealing with this problem, the **Hash** is introduced. **Hash is the new method to give index for insertion or deletion**. For making index, hash uses hash function that converts given input index into key index for table. The table that features the hash is called **Hashtable**. Even though **hash functions** can have many expressions. As you can see in Figure 1-2, the **hash function** can be just basic expression using quadratic function. This function produces **proper key** which is the **position index of new node**.

<br/>

<br/>

## 1-B. Problem of HashTable

<br/>

However, the HashTable can cause another problem which is called **collision**. The problem of collision is happened when **two other nodes has the same key index** which is generated by hash function. In this case, the new one has no seat for itself as the old one which has same key index was already inserted. For overcoming this problem, the **two solutions** are usually considered.

<br/>

<br/>

![ChainHash_Figure1-3](https://i.imgur.com/TRBqtv4.png)

<br/>

![ChainHash_Figure1-4](https://i.imgur.com/beOSJgH.png)

<br/>

One way is called **Open Address**. **Open Address** is the **method of finding the new empty index instead of existing filled index**. In the case of the _Figure 1-3_, **by adding integer until finding empty index**, it fills the empty space with new node.

<br/>

The other way is called **Chaining method**. **Chaining** is the method that connects the existing node with new node as LinkedList which are having same key index like _Figure 1-4_.

<br/>

Each method has **advantages** and **disadvantages**. In case of **Open Address**, as each table's blank is filled with only one node, this method **requires only O(1) when searching one node**. However, as **it should find blank table until the new node can be inserted** into blank table, **it requires more time when the node is inserted** than **Chaining method**. And also, **its capacity of nodes are limited to its table size**. On the other hand, in case of **Chaining method**, unlike the **Open Address**, it **doesn't have to find any blank node for insertion** as **it inserts new node by linking with existing node**. But, it can **spend more time to search specific node** as it is **chained with other nodes** like _Figure 1-4._

<br/>
  
In this chapter, instead of **Open Address** method, the **Chaining method** will be introduced.

<br/>

<br/>

## 1-C. How to do Chaining nodes?

<br/>

<br/>

![ChainHash_Figure1-5](https://i.imgur.com/3BUtmID.png)

<br/>

![ChanHash_Figure1-6](https://i.imgur.com/OUEKs4F.png)

<br/>

**Chaining** one node with other nodes is not that difficult job. As what you have to do is just utilizing the **LinkedList**. Let's imagine the situation that **inserts the new node into HashTable**. As you can see in above _Figure 1-5_, let's assume that **the new node which has α has key value as 2** which is produced by hash function h(x). Because the **LinkedList** in key value 2 has other nodes, **the new node α should be chained** with other node **which is the end of the chain** of the key value 2 table. So the **new node α is supposed to be inserted next to the node μ**.

<br/>

To do so, at first, **it finds the last position of the LinkedList** by **checking whether the next pointer in the node points nothing** or not. . For example, in _Figure 1-6_, the last position is the **node μ** as **its next pointer in this node points nothing**. Then the **new node is inserted into the position next to node μ**.

<br/>

<br/>

# 2. ADT(Abstract Data Type)

<br/>

<br/>

## 2-1. DataStructures for ChainHash

<br/>

```mermaid
graph LR
A(Chain HashTable) --- B(int size)
A --- C(Node **ChainNode)
B --- D[Integer that contains the size of HashTable]
C --> F(Node *)
C --> G(Node *)
C --> K( ... )
F --> F1(Node)
F1 --> F2(Node)
F2 --> F3(Node)
F3 --> F4( ... )
G --> G1(Node)
G1 --> G2(Node)
G2 --> G3(Node)
G3 --> G4( ... )
```

<br/>

```mermaid
graph LR
A(Node) --- B(Member)
A --- C(struct Node *next)
B --- D(char *name)
B --- E(int no)
C --> F(Node)

```

<br/>


- **ChainHash** has integer value **which contains the size of the HashTable** and **Node double pointer** which points the **Node pointer** that points the **Node**.

- **Node** contains **structure Member** and **Node pointer next** which **points the next Node**.

- **Member** contains **char type pointer(actually the char type array)** and the **integer value** that contains **number(no)**.

<br/>

<br/>

# 3. Functions

<br/>

<br/>

# 3-1. Member(.c)

<br/>

## 3-1-A. int cmpMemberName(const Member *m1, const Member *m2)

<br/>

This is the function that **compares the names between Member *m1 and Member *m2** using **strcmp** from **<string.h>**. The **parameters** are **const** for **preventing them from being changed** by this function.

<br/>

<br/>

## 3-1-B. int cmpMemberName(const Member *m1, const Member *m2)

<br/>

This is the function that **compares the numbers between Member *m1 and Member *m2**. If **m1's number is bigger**, then it **returns 0**. Else it **returns -1.**

<br/>

<br/>

## 3-1-C. Member ScanMember(char \*message, int sw)

<br/>

This is the function that **scans the Member's datas** when the node needs to be **inserted or deleted or searched**. The Input data **sw** is the indicator whether this function will scan **only name** or **only no** or **both of them**. For example, if you want to **scan only name**, then **sw** should be **MEMBER_NAME**. If you want to **scan both of them**, then **sw** should be **MEMBER_NO | MEMBER_NAME.**

<br/>

<br/>

# 3-2. ChainHash(.c)

<br/>

## 3-2-A. void Initialize(ChainHash \*chain, int size)

<br/>

It is the function that **initializes the Chain HashTable**. To create **Chain structure pointer array**, **ChainNode** is allocated **Node pointers that points node** and **their quantity** is the **size**. After that, the **size** is set as **input size**.

<br/>

<br/>
  
## 3-2-B. int HashFunc(char *name, ChainHash *chain)

<br/>

<br/>

![ChainHash_Figure3-1](https://i.imgur.com/qgZ1NPg.png)

<br/>

It is the **function that creates key value** according to the **input name** and the **size of HashTable**. First, it creates a value which is **the sum of characters' integer values of name using integer type casting**. After that, it returns **the sum which is divided by the size of Chain HashTable**.

<br/>

<br/>

## 3-2-C. Node *SetNodeInfo(Member data, Node *next)

<br/>

It is the function that **allocates and sets the new node** to be **inserted into HashTable**. After it allocates new node, it **sets the Node's no and name**. In case of the name, it uses **strcpy** from **<string.h>**. After that, it makes **next pointer in Node point to the input** next for **connecting them**.

<br/>

<br/>

## 3-2-D. int Add(ChainHash \*chain, Member data)

<br/>

It is the function that **adds the new Node into HashTable**. **Based on the data's name**, it **creates the key value** using **HashFunc**. After that based on the **Member data**, it creates new **Node to be inserted**. There are **two cases** for insertion processes.

<br/>

### Case 1 : Node pointer in HashTable at key th points _NULL_.

<br/>

<br/>

![ChainHash_Figure3-2](Figure that describes the the Node pointer in the key points nothing)

<br/>

In this case, what you have to do is just **inserting the new node into HashTable by connecting the new node with Node pointer in key th position** like above _Figure 3-2_.

<br/>

### Case 2 : Node pointer in HashTable at key value's position points existing Node.

<br/>

<br/>

![ChainHash_Figure3-3](Figure that describes the Node pointer in the key points something)

<br/>

In this case, you have to do **two things** to insert new node. First, you have to **find whether the new node's name or no is already used by other existing nodes**. By using **cmpMemberName and cmpMemberNo in Member.c**, you can detect any repeated name or no. If so, the task for **adding new node is failed**.

<br/>

Next, **if repeated things are not detected**, you have to **find the Node that its next pointer points nothing to look for the postiion to be inserted**. 

<br/>

These processes are repeated until the current node's next pointer points nothing like above _Figure 3-3_. After they are done, the new node is inserted.

<br/>

<br/>

## 3-2-E. int Delete(ChainHash *chain, char *name)

<br/>

<br/>

![ChainHash_Figure3-4](Figure that describes the situation that compares the two names' keys)

<br/>

It is the function that deletes the node in the HashTable which has same name with the given input name. For doing so, you have to get the key value from given input name. By using HashFunc, you can get the key value. After that, using given key value, you have to reach to the Node pointer in key th HashTable. Searching through all Node in the key th ChainHash, it compares the input name with the name in the selected node. If two names are considered to be same by strcmp in <string.h>, then the selected node should be deleted. For making existing nodes be connected with each other except the node to be deleted, the two pointers that points Node are needed. On this function, tmp and prev are used. Pointer tmp points the target node to be deleted and prev points the node which is front of the node pointed by pointer tmp.

<br/>

After it finds the target node to be deleted by using strcmp, it checks whether the tmp points a node. If not so, the deletion processes are failed as there is nothing to be deleted. If tmp points something, there are two cases for deletion.

<br/>

### Case 1 : Prev points a node. 

<br/>

<br/>

It is the case the node in front of the target node 

<br/>

### case 2 : Prev points nothing.

<br/>

<br/>

<br/>

## 3-1-C. ExpressionTree.c

<br/>

### C-1. int is_digit(char \*token)

<br/>

It is the function that **checks whether the given token(a collection of chars) is number or not**. It checks **two conditions** to confirm it. **One condition is checking the return value of function atoi** which changes the given string into number and **returns 0 if given token is not number**. **Second condition is the given string is not "0" using strcmp** because there can be cases that the given token is "0". By theses conditions, the given token is decided to be digit then it returns _TRUE(1)_. Else it returns _FALSE(0)_.

<br/>

<br/>

### C-2. BinNode \*MakeExpTree(char expression[MAXEXP])

<br/>

<br/>

![ExpressionTree_Figure3-1](./images/ExpressionTree_Figure3-1.png)

<br/>

It is the function that **makes expression tree using given postfix expression**. This function can be expressed as the above _Figure 3-1_.

<br/>

As I mentioned in **_chapter 1-B_**, the process of converting to expression tree becomes different by checking that the digit is read or not using function **is_digit**. When the **digit is read**, **the new node for BinaryTree is created and contains the read digit** like upper one in _Figure 1-2-1_. However, **if the read one is not digit but operator** then **the new node that contains operator is created popping two nodes in Stack for creating new subtree** like lower one in _Figure 1-2-1_.

<br/>

These processes **are repeated until there is no more things to be read in given postfix expression**. After that, the **root node of expression tree becomes a node at top of the stack** which is returned at the end of this function. Before returning the root node. **it clears out the allocated stack** which is **used for converting process**.

<br/>

<br/>

### C-3. int EvaluateExpTree(BinNode \*nde)

<br/>

<br/>

![ExpressionTree_Figure3-2](./images/ExpressionTree_Figure3-2.png)

<br/>

![ExpressionTree_Figure3-3](./images/ExpressionTree_Figure3-3.png)

<br/>

It is the function that **evaluates the total value of the given expression tree**. As you can see the code of this function, it is **recursive function**. The reason I made this function as recursive function is that the converted expression tree is **the collection of subtrees**. As you can see in _Figure 3-2_, the converted expression tree can be considered as the **collection of subtree which has one operator with two operands.** That's why the expression tree can be expressed easier like the _Figure 3-3_.

<br/>

Based on these facts, calculating the expression tree should be done **after calculating left subtree and right subtree**. After **finishing calculation of left subtree and right subtree** which becomes each left operand and right operand, **the calculation between these two operands is done based on the read operator**. And then it returns the result value to become the upper tree's operand.

<br/>

<br/>

### C-4. showInfixExp(BinNode *nde), showPostfixExp(BinNode *nde), showPrefixExp(BinNode \*nde)

It is the function that **converts the given expression tree into infix(or postfix or prefix) expression**. What you have to do is just **traveling the given tree as the appropriate order**. For example, function showInfixExp is supposed to **travel the expression tree by preorder traversal visiting in order of left child, root node, right child.** And for **improving the visuality**, whenever the root node value is printed, **the space(" ") is inserted.**

<br/>

<br/>

# 4. Conclusion

It is the program that **converts the given expression into expression tree and convert it into expression again**. As this program uses both stack and binary tree considering the rules of expression for realizing this function, it is considered one of the most complicated programs in my thought.
